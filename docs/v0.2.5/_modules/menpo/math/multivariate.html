

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>menpo.math.multivariate &mdash; Menpo 0.2.5 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="top" title="Menpo 0.2.5 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="../../../index.html" class="fa fa-home"> Menpo</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../overview.html">Introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../overview.html#id1">Overview</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">The Menpo API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../api/index.html#packages">Packages</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">Menpo</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      
    <li>menpo.math.multivariate</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            
  <h1>Source code for menpo.math.multivariate</h1><div class="highlight"><pre>
<span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">This is the one function we require from SciPy 0.14.0. Unfortunately the</span>
<span class="sd">version of SciPy we can get people to install via conda is 0.13.3 for the</span>
<span class="sd">time being.</span>

<span class="sd">Fortunately the function is pure Python, so we can copy it in here and only</span>
<span class="sd">depend on SciPy 0.13.3 in the interim.</span>

<span class="sd">As soon as SciPy 0.14.0 is readily available as a conda package this should be</span>
<span class="sd">removed.</span>


<span class="sd">----------------------------- SCIPY LICENCE -----------------------------------</span>
<span class="sd">Copyright (c) 2001, 2002 Enthought, Inc.</span>
<span class="sd">All rights reserved.</span>

<span class="sd">Copyright (c) 2003-2012 SciPy Developers.</span>
<span class="sd">All rights reserved.</span>

<span class="sd">Redistribution and use in source and binary forms, with or without</span>
<span class="sd">modification, are permitted provided that the following conditions are met:</span>

<span class="sd">  a. Redistributions of source code must retain the above copyright notice,</span>
<span class="sd">     this list of conditions and the following disclaimer.</span>
<span class="sd">  b. Redistributions in binary form must reproduce the above copyright</span>
<span class="sd">     notice, this list of conditions and the following disclaimer in the</span>
<span class="sd">     documentation and/or other materials provided with the distribution.</span>
<span class="sd">  c. Neither the name of Enthought nor the names of the SciPy Developers</span>
<span class="sd">     may be used to endorse or promote products derived from this software</span>
<span class="sd">     without specific prior written permission.</span>


<span class="sd">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="sd">AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="sd">IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="sd">ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS</span>
<span class="sd">BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,</span>
<span class="sd">OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="sd">SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="sd">INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="sd">CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="sd">ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF</span>
<span class="sd">THE POSSIBILITY OF SUCH DAMAGE.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c">#</span>
<span class="c"># Author: Joris Vankerschaver 2013</span>
<span class="c">#</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">absolute_import</span>

<span class="kn">from</span> <span class="nn">scipy.misc</span> <span class="kn">import</span> <span class="n">doccer</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;multivariate_normal&#39;</span><span class="p">]</span>


<span class="n">_LOG_2PI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_process_parameters</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Infer dimensionality from mean or covariance matrix, ensure that</span>
<span class="sd">    mean and covariance are full vector resp. matrix.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Try to infer dimensionality</span>
    <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mean</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cov</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cov</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">dim</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dim</span> <span class="o">=</span> <span class="n">cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="n">mean</span><span class="o">.</span><span class="n">size</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Dimension of random variable must be a scalar.&quot;</span><span class="p">)</span>

    <span class="c"># Check input sizes and return full arrays for mean and cov if necessary</span>
    <span class="k">if</span> <span class="n">mean</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
    <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">cov</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">cov</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">mean</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
        <span class="n">cov</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mean</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">mean</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Array &#39;mean&#39; must be vector of length </span><span class="si">%d</span><span class="s">.&quot;</span> <span class="o">%</span> <span class="n">dim</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cov</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">cov</span> <span class="o">=</span> <span class="n">cov</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">cov</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">cov</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Array &#39;cov&#39; must be at most two-dimensional,&quot;</span>
                                 <span class="s">&quot; but cov.ndim = </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">cov</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dim</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov</span>


<span class="k">def</span> <span class="nf">_process_quantiles</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adjust quantiles array so that last axis labels the components of</span>
<span class="sd">    each data point.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

    <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span> <span class="nf">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove single-dimensional entries from array and convert to scalar,</span>
<span class="sd">    if necessary.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[()]</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">_pinv_1d</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A helper function for computing the pseudoinverse.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : iterable of numbers</span>
<span class="sd">        This may be thought of as a vector of eigenvalues or singular values.</span>
<span class="sd">    eps : float</span>
<span class="sd">        Elements of v smaller than eps are considered negligible.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    v_pinv : 1d float ndarray</span>
<span class="sd">        A vector of pseudo-inverted numbers.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">eps</span> <span class="k">else</span> <span class="mi">1</span><span class="o">/</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">v</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_psd_pinv_decomposed_log_pdet</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">cond</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                                  <span class="n">lower</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute a decomposition of the pseudo-inverse and the logarithm of</span>
<span class="sd">    the pseudo-determinant of a symmetric positive semi-definite</span>
<span class="sd">    matrix.</span>

<span class="sd">    The pseudo-determinant of a matrix is defined as the product of</span>
<span class="sd">    the non-zero eigenvalues, and coincides with the usual determinant</span>
<span class="sd">    for a full matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mat : array_like</span>
<span class="sd">        Input array of shape (`m`, `n`)</span>
<span class="sd">    cond, rcond : float or None</span>
<span class="sd">        Cutoff for &#39;small&#39; singular values.</span>
<span class="sd">        Eigenvalues smaller than ``rcond*largest_eigenvalue``</span>
<span class="sd">        are considered zero.</span>
<span class="sd">        If None or -1, suitable machine precision is used.</span>
<span class="sd">    lower : bool, optional</span>
<span class="sd">        Whether the pertinent array data is taken from the lower or upper</span>
<span class="sd">        triangle of `mat`. (Default: lower)</span>
<span class="sd">    check_finite : boolean, optional</span>
<span class="sd">        Whether to check that the input matrix contains only finite numbers.</span>
<span class="sd">        Disabling may give a performance gain, but may result in problems</span>
<span class="sd">        (crashes, non-termination) if the inputs do contain infinities or NaNs.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    M : array_like</span>
<span class="sd">        The pseudo-inverse of the input matrix is np.dot(M, M.T).</span>
<span class="sd">    log_pdet : float</span>
<span class="sd">        Logarithm of the pseudo-determinant of the matrix.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Compute the symmetric eigendecomposition.</span>
    <span class="c"># The input covariance matrix is required to be real symmetric</span>
    <span class="c"># and positive semidefinite which implies that its eigenvalues</span>
    <span class="c"># are all real and non-negative,</span>
    <span class="c"># but clip them anyway to avoid numerical issues.</span>

    <span class="c"># TODO: the code to set cond/rcond is identical to that in</span>
    <span class="c"># scipy.linalg.{pinvh, pinv2} and if/when this function is subsumed</span>
    <span class="c"># into scipy.linalg it should probably be shared between all of</span>
    <span class="c"># these routines.</span>

    <span class="c"># Note that eigh takes care of array conversion, chkfinite,</span>
    <span class="c"># and assertion that the matrix is square.</span>
    <span class="n">s</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="n">lower</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="n">check_finite</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">rcond</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">rcond</span>
    <span class="k">if</span> <span class="n">cond</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;f&#39;</span><span class="p">:</span> <span class="mf">1E3</span><span class="p">,</span> <span class="s">&#39;d&#39;</span><span class="p">:</span> <span class="mf">1E6</span><span class="p">}</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">factor</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="n">cond</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">eps</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;the covariance matrix must be positive semidefinite&#39;</span><span class="p">)</span>

    <span class="n">s_pinv</span> <span class="o">=</span> <span class="n">_pinv_1d</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s_pinv</span><span class="p">))</span>
    <span class="n">log_pdet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">s</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">U</span><span class="p">,</span> <span class="n">log_pdet</span>


<span class="n">_doc_default_callparams</span> <span class="o">=</span> \
<span class="sd">&quot;&quot;&quot;mean : array_like, optional</span>
<span class="sd">    Mean of the distribution (default zero)</span>
<span class="sd">cov : array_like, optional</span>
<span class="sd">    Covariance matrix of the distribution (default one)</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">_doc_callparams_note</span> <span class="o">=</span> \
<span class="sd">&quot;&quot;&quot;Setting the parameter `mean` to `None` is equivalent to having `mean`</span>
<span class="sd">be the zero-vector. The parameter `cov` can be a scalar, in which case</span>
<span class="sd">the covariance matrix is the identity times that value, a vector of</span>
<span class="sd">diagonal entries for the covariance matrix, or a two-dimensional</span>
<span class="sd">array_like.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">_doc_frozen_callparams</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>

<span class="n">_doc_frozen_callparams_note</span> <span class="o">=</span> \
<span class="sd">&quot;&quot;&quot;See class definition for a detailed description of parameters.&quot;&quot;&quot;</span>

<span class="n">docdict_params</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;_doc_default_callparams&#39;</span><span class="p">:</span> <span class="n">_doc_default_callparams</span><span class="p">,</span>
    <span class="s">&#39;_doc_callparams_note&#39;</span><span class="p">:</span> <span class="n">_doc_callparams_note</span>
<span class="p">}</span>

<span class="n">docdict_noparams</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;_doc_default_callparams&#39;</span><span class="p">:</span> <span class="n">_doc_frozen_callparams</span><span class="p">,</span>
    <span class="s">&#39;_doc_callparams_note&#39;</span><span class="p">:</span> <span class="n">_doc_frozen_callparams_note</span>
<span class="p">}</span>


<span class="k">class</span> <span class="nc">multivariate_normal_gen</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    A multivariate normal random variable.</span>

<span class="sd">    The `mean` keyword specifies the mean. The `cov` keyword specifies the</span>
<span class="sd">    covariance matrix.</span>

<span class="sd">    .. versionadded:: 0.14.0</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    pdf(x, mean=None, cov=1)</span>
<span class="sd">        Probability density function.</span>
<span class="sd">    logpdf(x, mean=None, cov=1)</span>
<span class="sd">        Log of the probability density function.</span>
<span class="sd">    rvs(mean=None, cov=1)</span>
<span class="sd">        Draw random samples from a multivariate normal distribution.</span>
<span class="sd">    entropy()</span>
<span class="sd">        Compute the differential entropy of the multivariate normal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        Quantiles, with the last axis of `x` denoting the components.</span>
<span class="sd">    %(_doc_default_callparams)s</span>

<span class="sd">    Alternatively, the object may be called (as a function) to fix the mean</span>
<span class="sd">    and covariance parameters, returning a &quot;frozen&quot; multivariate normal</span>
<span class="sd">    random variable:</span>

<span class="sd">    rv = multivariate_normal(mean=None, scale=1)</span>
<span class="sd">        - Frozen  object with the same methods but holding the given</span>
<span class="sd">          mean and covariance fixed.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    %(_doc_callparams_note)s</span>

<span class="sd">    The covariance matrix `cov` must be a (symmetric) positive</span>
<span class="sd">    semi-definite matrix. The determinant and inverse of `cov` are computed</span>
<span class="sd">    as the pseudo-determinant and pseudo-inverse, respectively, so</span>
<span class="sd">    that `cov` does not need to have full rank.</span>

<span class="sd">    The probability density function for `multivariate_normal` is</span>

<span class="sd">    .. math::</span>

<span class="sd">        f(x) = \frac{1}{\sqrt{(2 \pi)^k \det \Sigma}} \exp\left( -\frac{1}{2} (x - \mu)^T \Sigma^{-1} (x - \mu) \right),</span>

<span class="sd">    where :math:`\mu` is the mean, :math:`\Sigma` the covariance matrix,</span>
<span class="sd">    and :math:`k` is the dimension of the space where :math:`x` takes values.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.stats import multivariate_normal</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(0, 5, 10, endpoint=False)</span>
<span class="sd">    &gt;&gt;&gt; y = multivariate_normal.pdf(x, mean=2.5, cov=0.5); y</span>
<span class="sd">    array([ 0.00108914,  0.01033349,  0.05946514,  0.20755375,  0.43939129,</span>
<span class="sd">            0.56418958,  0.43939129,  0.20755375,  0.05946514,  0.01033349])</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(x, y)</span>

<span class="sd">    The input quantiles can be any shape of array, as long as the last</span>
<span class="sd">    axis labels the components.  This allows us for instance to</span>
<span class="sd">    display the frozen pdf for a non-isotropic random variable in 2D as</span>
<span class="sd">    follows:</span>

<span class="sd">    &gt;&gt;&gt; x, y = np.mgrid[-1:1:.01, -1:1:.01]</span>
<span class="sd">    &gt;&gt;&gt; pos = np.empty(x.shape + (2,))</span>
<span class="sd">    &gt;&gt;&gt; pos[:, :, 0] = x; pos[:, :, 1] = y</span>
<span class="sd">    &gt;&gt;&gt; rv = multivariate_normal([0.5, -0.2], [[2.0, 0.3], [0.3, 0.5]])</span>
<span class="sd">    &gt;&gt;&gt; plt.contourf(x, y, rv.pdf(pos))</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__doc__</span><span class="p">,</span> <span class="n">docdict_params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a frozen multivariate normal distribution.</span>

<span class="sd">        See `multivariate_normal_frozen` for more information.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">multivariate_normal_frozen</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">prec_U</span><span class="p">,</span> <span class="n">log_det_cov</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : ndarray</span>
<span class="sd">            Points at which to evaluate the log of the probability</span>
<span class="sd">            density function</span>
<span class="sd">        mean : ndarray</span>
<span class="sd">            Mean of the distribution</span>
<span class="sd">        prec_U : ndarray</span>
<span class="sd">            A decomposition such that np.dot(prec_U, prec_U.T)</span>
<span class="sd">            is the precision matrix, i.e. inverse of the covariance matrix.</span>
<span class="sd">        log_det_cov : float</span>
<span class="sd">            Logarithm of the determinant of the covariance matrix</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        As this function does no argument checking, it should not be</span>
<span class="sd">        called directly; use &#39;logpdf&#39; instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">dev</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">mean</span>
        <span class="n">maha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">prec_U</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">dim</span> <span class="o">*</span> <span class="n">_LOG_2PI</span> <span class="o">+</span> <span class="n">log_det_cov</span> <span class="o">+</span> <span class="n">maha</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Log of the multivariate normal probability density function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            Quantiles, with the last axis of `x` denoting the components.</span>
<span class="sd">        %(_doc_default_callparams)s</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_doc_callparams_note)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pdf : ndarray</span>
<span class="sd">            Log of the probability density function evaluated at `x`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov</span> <span class="o">=</span> <span class="n">_process_parameters</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">_process_quantiles</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
        <span class="n">prec_U</span><span class="p">,</span> <span class="n">log_det_cov</span> <span class="o">=</span> <span class="n">_psd_pinv_decomposed_log_pdet</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">prec_U</span><span class="p">,</span> <span class="n">log_det_cov</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multivariate normal probability density function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            Quantiles, with the last axis of `x` denoting the components.</span>
<span class="sd">        %(_doc_default_callparams)s</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_doc_callparams_note)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pdf : ndarray</span>
<span class="sd">            Probability density function evaluated at `x`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov</span> <span class="o">=</span> <span class="n">_process_parameters</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">_process_quantiles</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
        <span class="n">prec_U</span><span class="p">,</span> <span class="n">log_det_cov</span> <span class="o">=</span> <span class="n">_psd_pinv_decomposed_log_pdet</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">prec_U</span><span class="p">,</span> <span class="n">log_det_cov</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw random samples from a multivariate normal distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_doc_default_callparams)s</span>
<span class="sd">        size : integer, optional</span>
<span class="sd">            Number of samples to draw (default 1).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_doc_callparams_note)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rvs : ndarray or scalar</span>
<span class="sd">            Random variates of size (`size`, `N`), where `N` is the</span>
<span class="sd">            dimension of the random variable.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov</span> <span class="o">=</span> <span class="n">_process_parameters</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the differential entropy of the multivariate normal.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        %(_doc_default_callparams)s</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        %(_doc_callparams_note)s</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        h : scalar</span>
<span class="sd">            Entropy of the multivariate normal distribution</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dim</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov</span> <span class="o">=</span> <span class="n">_process_parameters</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">e</span> <span class="o">*</span> <span class="n">cov</span><span class="p">))</span>

<span class="n">multivariate_normal</span> <span class="o">=</span> <span class="n">multivariate_normal_gen</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">multivariate_normal_frozen</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a frozen multivariate normal distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mean : array_like, optional</span>
<span class="sd">            Mean of the distribution (default zero)</span>
<span class="sd">        cov : array_like, optional</span>
<span class="sd">            Covariance matrix of the distribution (default one)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        When called with the default parameters, this will create a 1D random</span>
<span class="sd">        variable with mean 0 and covariance 1:</span>

<span class="sd">        &gt;&gt;&gt; from scipy.stats import multivariate_normal</span>
<span class="sd">        &gt;&gt;&gt; r = multivariate_normal()</span>
<span class="sd">        &gt;&gt;&gt; r.mean</span>
<span class="sd">        array([ 0.])</span>
<span class="sd">        &gt;&gt;&gt; r.cov</span>
<span class="sd">        array([[1.]])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov</span> <span class="o">=</span> <span class="n">_process_parameters</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">cov</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prec_U</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_det_cov</span> <span class="o">=</span> <span class="n">_psd_pinv_decomposed_log_pdet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_mnorm</span> <span class="o">=</span> <span class="n">multivariate_normal_gen</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">_process_quantiles</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mnorm</span><span class="o">.</span><span class="n">_logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prec_U</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_det_cov</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_squeeze_output</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mnorm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the differential entropy of the multivariate normal.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        h : scalar</span>
<span class="sd">            Entropy of the multivariate normal distribution</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">*</span> <span class="p">(</span><span class="n">_LOG_2PI</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_det_cov</span><span class="p">)</span>


<span class="c"># Set frozen generator docstrings from corresponding docstrings in</span>
<span class="c"># multivariate_normal_gen and fill in default strings in class docstrings</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;logpdf&#39;</span><span class="p">,</span> <span class="s">&#39;pdf&#39;</span><span class="p">,</span> <span class="s">&#39;rvs&#39;</span><span class="p">]:</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">multivariate_normal_gen</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="n">method_frozen</span> <span class="o">=</span> <span class="n">multivariate_normal_frozen</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="n">method_frozen</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="n">__doc__</span><span class="p">,</span> <span class="n">docdict_noparams</span><span class="p">)</span>
    <span class="n">method</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="n">__doc__</span><span class="p">,</span> <span class="n">docdict_params</span><span class="p">)</span>
</pre></div>

          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014, Patrick Snape, James Booth, Joan Alabort-i-Medina and Nontas Antonakos.
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.2.5',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>